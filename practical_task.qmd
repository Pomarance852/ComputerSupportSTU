---
title: "Task1"
author: "Michal Hupka"
date: "28/10/2025"
format:
  html:
    embed-resources: true
editor: source

##############################################
# Mini Universe: The Town of Pezinok, Slovakia
##############################################

### 1.1 Atomic Types ----

# Numeric variables
population_density <- 780.5     # people per km^2
average_income <- 1250.75       # EUR per month
avg_temperature <- 10.8         # °C
area_size <- 72.56              # km^2

# Integer variables
number_of_wineries <- 25
number_of_parks <- 8
number_of_schools <- 12

# Logical variables
has_castle <- TRUE
is_capital_city <- FALSE

# Character variables
town_name <- "Pezinok"
region <- "Bratislava Region"
category <- "Wine-producing town"

# Description in one sentence
cat(paste(
  "The town of", town_name, "is a", category, "located in the",
  region, "with", number_of_wineries, "wineries and",
  population_density, "people per km².\n"
))

### 1.2 Vectors ----

# 1. Numeric vector combining numeric + integer variables
numeric_vector <- c(population_density, average_income, avg_temperature,
                    area_size, number_of_wineries, number_of_parks, number_of_schools)
print(numeric_vector)

# 2. Sequence vector from 20 to 100 with step of 8
seq_vector <- seq(20, 100, by = 8)
print(seq_vector)

# 3. Logical vector of 10 random TRUE/FALSE values
set.seed(123) # for reproducibility
logic_vector <- sample(c(TRUE, FALSE), 10, replace = TRUE)
print(logic_vector)

### 1.3 Matrix ----

# Create 3×3 matrix with random numbers between -50 and 50
set.seed(321)
town_matrix <- matrix(sample(-50:50, 9, replace = TRUE), nrow = 3, ncol = 3)

# Name rows and columns
rownames(town_matrix) <- c("Center", "Suburbs", "Countryside")
colnames(town_matrix) <- c("Economy", "Environment", "Culture")

print(town_matrix)

# Calculate row and column averages
row_means <- rowMeans(town_matrix)
col_means <- colMeans(town_matrix)

cat("\nRow means:\n")
print(row_means)

cat("\nColumn means:\n")
print(col_means)

### 1.4 List ----

# Create a list combining all previous objects
pezinok_list <- list(
  numeric_values = list(population_density, average_income, avg_temperature, area_size),
  integer_values = list(number_of_wineries, number_of_parks, number_of_schools),
  logical_values = list(has_castle, is_capital_city),
  character_values = list(town_name, region, category),
  numeric_vector = numeric_vector,
  seq_vector = seq_vector,
  logic_vector = logic_vector,
  matrix = town_matrix,
  description = "Pezinok is a picturesque Slovak town known for its wine culture and proximity to the Little Carpathians."
)

print(pezinok_list$description)

### 1.5 Factor ----

# Factor representing wealth levels in different neighborhoods
neighborhood_wealth <- factor(
  c("medium", "high", "low", "medium", "high", "low"),
  levels = c("low", "medium", "high"),
  ordered = TRUE
)

print(neighborhood_wealth)
table(neighborhood_wealth)

### 1.6 Data Frame ----

# Create data frame for Pezinok’s main wineries
wineries_df <- data.frame(
  Name = c("Víno Matyšák", "Karpatská Perla", "Repa Winery", "Pivnica Radošina", "Zámocké Vinárstvo", "Vinohradníctvo Miroslav Dudo"),
  Annual_Production = c(120000, 95000, 70000, 55000, 40000, 30000),  # in liters
  Organic = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE),
  Quality_Level = c("high", "high", "medium", "medium", "medium", "low")
)

# Rename columns
colnames(wineries_df) <- c("Winery_Name", "Liters_Produced", "Is_Organic", "Quality")

# Display structure and summary
str(wineries_df)
summary(wineries_df)

# Add new derived column: production category based on output
wineries_df$Production_Category <- ifelse(
  wineries_df$Liters_Produced > 80000, "Large",
  ifelse(wineries_df$Liters_Produced > 50000, "Medium", "Small")
)


print(wineries_df)

###############################################################
# TASK 2 – Subsetting & Missing Data
# Based on data and objects from Task 1 (Pezinok dataset)
###############################################################

### 2.1 Querying Vectors ----

## 2.1.1 Sequence vector (seq_vector)
# Print the 3rd element
seq_vector[3]

# Print elements 2 through 5
seq_vector[2:5]

# Print all values greater than 40
seq_vector[seq_vector > 40]


## 2.1.2 Logical vector (logic_vector)
# Select and print only TRUE values
logic_vector[logic_vector]

# Get indices (positions) of all TRUE values
which(logic_vector)


### 2.2 Querying Your “Universe” List ----

## Access and print the description string using the $ operator
pezinok_list$description

## Access and print your 3x3 matrix using double brackets [[ ]]
pezinok_list[["matrix"]]

## Access and print the 2nd element from your numeric_vector inside the list
# (Remember: numeric_vector is stored as a list element within pezinok_list)
pezinok_list[["numeric_vector"]][2]


### 2.3 Investigating Your Data Frame ----

## Print the first 3 rows
head(wineries_df, 3)

## Print the value from the 4th row, 1st column
wineries_df[4, 1]

## Print only the logical column (Is_Organic) as a vector
wineries_df$Is_Organic

## Logical Subsetting – select only organic wineries
df_subset <- wineries_df[wineries_df$Is_Organic == TRUE, ]
df_subset

## %in% Subsetting – select wineries with “high” or “medium” Quality
df_subset_2 <- wineries_df[wineries_df$Quality %in% c("high", "medium"), ]
df_subset_2


### 2.4 Handling “Corrupted” Data (NA) ----

## Create a copy of the data frame
df_corrupted <- wineries_df

## Introduce 3 NA values
df_corrupted[2, "Is_Organic"] <- NA
df_corrupted[5, "Quality"] <- NA
df_corrupted[6, "Liters_Produced"] <- NA

## Find total number of missing values
sum(is.na(df_corrupted))

## Find number of NAs per column
colSums(is.na(df_corrupted))

## Calculate mean of numeric column (Liters_Produced) with NA
mean(df_corrupted$Liters_Produced, na.rm = TRUE)

## Remove rows with any NA values
df_clean <- na.omit(df_corrupted)
df_clean


### 2.5 Bonus Challenge: which() ----

## Find row with the maximum production
max_index <- which.max(wineries_df$Liters_Produced)
wineries_df[max_index, ]

## Find row with the minimum production
min_index <- which.min(wineries_df$Liters_Produced)
wineries_df[min_index, ]
